// YatAuthenticator.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Alamofire

{{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}open{{/nonPublicApi}} class YatAuthenticator: Authenticator {

    {{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}public{{/nonPublicApi}} init() { }

    {{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}open{{/nonPublicApi}} func apply(_ credential: YatCredentials, to urlRequest: inout URLRequest) {
        urlRequest.headers.add(.authorization(bearerToken: credential.accessToken))
    }

    {{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}public{{/nonPublicApi}} func refresh(_ credential: YatCredentials,
                 for session: Session,
                 completion: @escaping (Result<YatCredentials, Error>) -> Void) {
        // Refresh the credential using the refresh token...then call completion with the new credential.
        //
        // The new credential will automatically be stored within the `AuthenticationInterceptor`. Future requests will
        // be authenticated using the `apply(_:to:)` method using the new credential.
        if let yatCredential = YatSDKAPI.yatCredential {
            let request = RefreshRequest(refreshToken: yatCredential.refreshToken)
            UserAuthenticationAPI.refreshToken(body: request) { (result) in
                switch result {
                    case .success(let token): do {
                        let credentials = YatCredentials(accessToken: token.accessToken, refreshToken: token.refreshToken)
                        YatSDKAPI.yatCredential = credentials
                        completion(.success(credentials))
                    }
                    case .failure(let error): completion(.failure(error))
                }
            }
        }
    }

    {{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}public{{/nonPublicApi}} func didRequest(_ urlRequest: URLRequest,
                    with response: HTTPURLResponse,
                    failDueToAuthenticationError error: Error) -> Bool {
        return response.statusCode == 401
    }

    {{#nonPublicApi}}internal{{/nonPublicApi}}{{^nonPublicApi}}public{{/nonPublicApi}} func isRequest(_ urlRequest: URLRequest, authenticatedWith credential: YatCredentials) -> Bool {
        let bearerToken = HTTPHeader.authorization(bearerToken: credential.accessToken).value
        return urlRequest.headers["Authorization"] == bearerToken
    }

}
